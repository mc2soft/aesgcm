package aesgcm

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/binary"
	"fmt"
	"io"
	"time"
)

const (
	// KeySize is AES-256 key size
	KeySize = 32

	// NonceSize is size of nonce (IV) for AES-256-GCM
	NonceSize = 12 // == gcm.NonceSize()

	// TagSize is authentication tag size for AES-256-GCM
	TagSize = 16 // gcm.Overhead()
)

// AesGcm stores key
type AesGcm struct {
	key []byte
}

// NewAesGcm creates new AesGcm with key
func NewAesGcm(key []byte) (*AesGcm, error) {
	if len(key) != KeySize {
		return nil, aes.KeySizeError(len(key))
	}
	return &AesGcm{key: key}, nil
}

// GenerateNonce generates nonce for AES-256-GCM from current time and RNG
func GenerateNonce() ([]byte, error) {
	b := make([]byte, NonceSize)
	now := uint64(time.Now().UnixNano())
	binary.BigEndian.PutUint64(b, now)
	_, err := io.ReadFull(rand.Reader, b[8:])
	if err != nil {
		return nil, err
	}
	return b, nil
}

// Seal encrypts and authenticates plaintext, authenticates the
// additional data (aad) and returns ciphertext together with authentication tag.
// The nonce must be NonceSize bytes long and unique for all
// time, for a given key. It can be generated by GenerateNonce.
func (a *AesGcm) Seal(plaintext, add, nonce []byte) ([]byte, error) {
	if len(nonce) != NonceSize {
		return nil, fmt.Errorf("AesGcm.Seal: invalid nonce size %d", nonce)
	}

	c, err := aes.NewCipher(a.key)
	if err != nil {
		return nil, err
	}
	gcm, err := cipher.NewGCM(c)
	if err != nil {
		return nil, err
	}
	out := gcm.Seal(nil, nonce, plaintext, add)
	return out, nil
}

// Open decrypts and authenticates ciphertext, authenticates the
// additional data (aad) and, if successful, returns plaintext.
// The nonce must be NonceSize bytes long and both it and the additional data
// must match the value passed to Seal.
func (a *AesGcm) Open(cryptotext, add, nonce []byte) ([]byte, error) {
	if len(nonce) != NonceSize {
		return nil, fmt.Errorf("AesGcm.Open: invalid nonce size %d", nonce)
	}

	c, err := aes.NewCipher(a.key)
	if err != nil {
		return nil, err
	}
	gcm, err := cipher.NewGCM(c)
	if err != nil {
		return nil, err
	}
	out, err := gcm.Open(nil, nonce, cryptotext, add)
	if err != nil {
		return nil, err
	}
	return out, nil
}
