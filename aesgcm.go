// Package aesgcm is a simple wrapper around standard library for AES-256-GCM.
package aesgcm

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/binary"
	"fmt"
	"io"
	"time"
)

const (
	// KeySize is AES-256 key size
	KeySize = 32

	// NonceSize is size of nonce (IV) for AES-256-GCM
	NonceSize = 12 // == gcm.NonceSize()

	// TagSize is authentication tag size for AES-256-GCM
	TagSize = 16 // gcm.Overhead()
)

// Aes256Gcm stores key
type Aes256Gcm struct {
	key []byte
}

// NewAes256Gcm creates new Aes256Gcm with key
func NewAes256Gcm(key []byte) (*Aes256Gcm, error) {
	if len(key) != KeySize {
		return nil, aes.KeySizeError(len(key))
	}
	return &Aes256Gcm{key: key}, nil
}

// GenerateNonce generates nonce for AES-256-GCM from current time and RNG
func GenerateNonce() ([]byte, error) {
	b := make([]byte, NonceSize)
	now := uint64(time.Now().UnixNano())
	binary.BigEndian.PutUint64(b, now)
	_, err := io.ReadFull(rand.Reader, b[8:])
	if err != nil {
		return nil, err
	}
	return b, nil
}

// Seal encrypts and authenticates plaintext, authenticates the
// additional data (aad) and returns ciphertext together with authentication tag.
// The nonce must be NonceSize bytes long and unique for all
// time, for a given key. It can be generated by GenerateNonce.
func (a *Aes256Gcm) Seal(plaintext, add, nonce []byte) ([]byte, error) {
	if len(nonce) != NonceSize {
		return nil, fmt.Errorf("Aes256Gcm.Seal: invalid nonce size %d", nonce)
	}

	c, err := aes.NewCipher(a.key)
	if err != nil {
		return nil, err
	}
	gcm, err := cipher.NewGCM(c)
	if err != nil {
		return nil, err
	}
	out := gcm.Seal(nil, nonce, plaintext, add)
	return out, nil
}

// Open decrypts and authenticates ciphertext, authenticates the
// additional data (aad) and, if successful, returns plaintext.
// The nonce must be NonceSize bytes long and both it and the additional data
// must match the value passed to Seal.
func (a *Aes256Gcm) Open(ciphertext, add, nonce []byte) ([]byte, error) {
	if len(nonce) != NonceSize {
		return nil, fmt.Errorf("Aes256Gcm.Open: invalid nonce size %d", nonce)
	}

	c, err := aes.NewCipher(a.key)
	if err != nil {
		return nil, err
	}
	gcm, err := cipher.NewGCM(c)
	if err != nil {
		return nil, err
	}
	out, err := gcm.Open(nil, nonce, ciphertext, add)
	if err != nil {
		return nil, err
	}
	return out, nil
}
